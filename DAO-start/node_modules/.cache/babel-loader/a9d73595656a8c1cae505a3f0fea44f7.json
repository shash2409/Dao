{"ast":null,"code":"import _asyncToGenerator from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/shash24/Desktop/Blockchain/Dao/DAO-start/node_modules/@babel/runtime/regenerator/index.js\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError, isHexStrict } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar WalletConnectV1Adapter = /*#__PURE__*/function (_BaseAdapter) {\n  _inherits(WalletConnectV1Adapter, _BaseAdapter);\n\n  var _super = _createSuper(WalletConnectV1Adapter);\n\n  function WalletConnectV1Adapter() {\n    var _this;\n\n    _classCallCheck(this, WalletConnectV1Adapter);\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(_assertThisInitialized(_this), \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(_assertThisInitialized(_this), \"adapterOptions\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(_assertThisInitialized(_this), \"adapterData\", {\n      uri: \"\"\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"connector\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"wcProvider\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"rehydrated\", false);\n\n    _this.adapterOptions = _objectSpread({}, options);\n    _this.chainConfig = options.chainConfig || null;\n    return _this;\n  }\n\n  _createClass(WalletConnectV1Adapter, [{\n    key: \"connected\",\n    get: function get() {\n      var _this$connector;\n\n      return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n    }\n  }, {\n    key: \"provider\",\n    get: function get() {\n      var _this$wcProvider;\n\n      return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n    },\n    set: function set(_) {\n      throw new Error(\"Not implemented\");\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _get(_getPrototypeOf(WalletConnectV1Adapter.prototype), \"checkInitializationRequirements\", this).call(this);\n\n                if (!this.chainConfig) {\n                  this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n                } // Create a connector\n\n\n                this.connector = this.getWalletConnectInstance();\n                this.wcProvider = new WalletConnectProvider({\n                  config: {\n                    chainConfig: this.chainConfig\n                  }\n                });\n                this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n                this.status = ADAPTER_STATUS.READY;\n\n                if (!this.connector.connected) {\n                  _context.next = 10;\n                  break;\n                }\n\n                this.rehydrated = true;\n                _context.next = 10;\n                return this.onConnectHandler({\n                  accounts: this.connector.accounts,\n                  chainId: this.connector.chainId.toString()\n                });\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this2 = this;\n\n        var _this$adapterOptions$;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _get(_getPrototypeOf(WalletConnectV1Adapter.prototype), \"checkConnectionRequirements\", this).call(this);\n\n                if (this.connector) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n              case 3:\n                if (!this.connected) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 6;\n                return this.onConnectHandler({\n                  accounts: this.connector.accounts,\n                  chainId: this.connector.chainId.toString()\n                });\n\n              case 6:\n                return _context4.abrupt(\"return\", this.provider);\n\n              case 7:\n                if (!(this.status !== ADAPTER_STATUS.CONNECTING)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n                // modal again on existing instance if connection is pending.\n                if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n                  this.connector = this.getWalletConnectInstance();\n                }\n\n                _context4.next = 11;\n                return this.createNewSession();\n\n              case 11:\n                this.status = ADAPTER_STATUS.CONNECTING;\n                this.emit(ADAPTER_EVENTS.CONNECTING, {\n                  adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n                });\n\n              case 13:\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (!_this2.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n                  // for wallet connect default modal.\n                  _this2.connector.on(\"modal_closed\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _this2.status = ADAPTER_STATUS.READY;\n\n                            _this2.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n                            return _context2.abrupt(\"return\", reject(new Error(\"User closed modal\")));\n\n                          case 3:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  })));\n\n                  try {\n                    // Subscribe to session connection\n                    _this2.connector.on(\"connect\", /*#__PURE__*/function () {\n                      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(error, payload) {\n                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                          while (1) {\n                            switch (_context3.prev = _context3.next) {\n                              case 0:\n                                if (error) {\n                                  _this2.emit(ADAPTER_EVENTS.ERRORED, error);\n                                }\n\n                                _context3.next = 3;\n                                return _this2.onConnectHandler(payload.params[0]);\n\n                              case 3:\n                                return _context3.abrupt(\"return\", resolve(_this2.provider));\n\n                              case 4:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }\n                        }, _callee3);\n                      }));\n\n                      return function (_x, _x2) {\n                        return _ref2.apply(this, arguments);\n                      };\n                    }());\n                  } catch (error) {\n                    log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n                    // ready again to be connected\n                    _this2.status = ADAPTER_STATUS.READY;\n                    _this2.rehydrated = true;\n\n                    _this2.emit(ADAPTER_EVENTS.ERRORED, error);\n\n                    reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n                  }\n                }));\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"getUserInfo\",\n    value: function () {\n      var _getUserInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.connected) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n\n              case 2:\n                return _context5.abrupt(\"return\", {});\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getUserInfo() {\n        return _getUserInfo.apply(this, arguments);\n      }\n\n      return getUserInfo;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var options,\n            cleanup,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {\n                  cleanup: false\n                };\n                cleanup = options.cleanup;\n\n                if (!(!this.connector || !this.connected)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n\n              case 4:\n                _context6.next = 6;\n                return this.connector.killSession();\n\n              case 6:\n                this.rehydrated = false;\n\n                if (cleanup) {\n                  this.connector = null;\n                  this.status = ADAPTER_STATUS.NOT_READY;\n                  this.wcProvider = null;\n                } else {\n                  // ready to connect again\n                  this.status = ADAPTER_STATUS.READY;\n                }\n\n                this.emit(ADAPTER_EVENTS.DISCONNECTED);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"createNewSession\",\n    value: function () {\n      var _createNewSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _this3 = this;\n\n        var _this$adapterOptions,\n            _this$adapterOptions$2,\n            opts,\n            _this$chainConfig,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                opts = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {\n                  forceNewSession: false\n                };\n\n                if (this.connector) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n              case 3:\n                if (!(opts.forceNewSession && this.connector.pending)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this.connector.killSession();\n\n              case 6:\n                if (!((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal)) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                _context8.next = 9;\n                return this.connector.createSession({\n                  chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n                });\n\n              case 9:\n                return _context8.abrupt(\"return\");\n\n              case 10:\n                return _context8.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var _this$chainConfig2;\n\n                  if (!_this3.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n                  log.debug(\"creating new session for web3auth wallet connect\");\n\n                  _this3.connector.on(\"display_uri\", /*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(err, payload) {\n                      var _this$connector2, uri;\n\n                      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                        while (1) {\n                          switch (_context7.prev = _context7.next) {\n                            case 0:\n                              if (!err) {\n                                _context7.next = 3;\n                                break;\n                              }\n\n                              _this3.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n\n                              return _context7.abrupt(\"return\", reject(err));\n\n                            case 3:\n                              uri = payload.params[0];\n\n                              _this3.updateAdapterData({\n                                uri: uri\n                              });\n\n                              (_this$connector2 = _this3.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n                              return _context7.abrupt(\"return\", resolve());\n\n                            case 7:\n                            case \"end\":\n                              return _context7.stop();\n                          }\n                        }\n                      }, _callee7);\n                    }));\n\n                    return function (_x3, _x4) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }());\n\n                  _this3.connector.createSession({\n                    chainId: parseInt(((_this$chainConfig2 = _this3.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n                  }).catch(function (error) {\n                    log.error(\"error while creating new wallet connect session\", error);\n\n                    _this3.emit(ADAPTER_EVENTS.ERRORED, error);\n\n                    return reject(error);\n                  });\n                }));\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function createNewSession() {\n        return _createNewSession.apply(this, arguments);\n      }\n\n      return createNewSession;\n    }()\n  }, {\n    key: \"onConnectHandler\",\n    value: function () {\n      var _onConnectHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {\n        var chainId, connectedChainId;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(!this.connector || !this.wcProvider)) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n              case 2:\n                if (this.chainConfig) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n\n              case 4:\n                chainId = params.chainId;\n                log.debug(\"connected chainId\", chainId);\n                connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n                if (!(connectedChainId !== parseInt(this.chainConfig.chainId, 16))) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                _context9.next = 10;\n                return this.createNewSession({\n                  forceNewSession: true\n                });\n\n              case 10:\n                this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(connectedChainId, \", Please switch to correct chain from wallet\")));\n                return _context9.abrupt(\"return\");\n\n              case 12:\n                _context9.next = 14;\n                return this.wcProvider.setupProvider(this.connector);\n\n              case 14:\n                this.subscribeEvents(this.connector);\n                this.status = ADAPTER_STATUS.CONNECTED;\n                this.emit(ADAPTER_EVENTS.CONNECTED, {\n                  adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n                  reconnected: this.rehydrated\n                });\n\n              case 17:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function onConnectHandler(_x5) {\n        return _onConnectHandler.apply(this, arguments);\n      }\n\n      return onConnectHandler;\n    }()\n  }, {\n    key: \"subscribeEvents\",\n    value: function subscribeEvents(connector) {\n      var _this4 = this;\n\n      connector.on(\"session_update\", /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(error) {\n          return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  if (error) {\n                    _this4.emit(ADAPTER_EVENTS.ERRORED, error);\n                  }\n\n                case 1:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10);\n        }));\n\n        return function (_x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"getWalletConnectInstance\",\n    value: function getWalletConnectInstance() {\n      var walletConnectOptions = this.adapterOptions.adapterSettings || {};\n      walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n      return new WalletConnect(walletConnectOptions);\n    }\n  }]);\n\n  return WalletConnectV1Adapter;\n}(BaseAdapter);\n\nexport { WalletConnectV1Adapter };","map":{"version":3,"sources":["../src/walletConnectV1adapter.ts"],"names":["WALLET_ADAPTERS","WALLET_CONNECT_V1","ADAPTER_NAMESPACES","EIP155","CHAIN_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","uri","constructor","options","connected","provider","init","getChainConfig","config","chainConfig","ADAPTER_EVENTS","accounts","chainId","connect","WalletInitializationError","adapter","reject","payload","resolve","log","error","WalletLoginError","getUserInfo","disconnect","cleanup","createNewSession","opts","forceNewSession","parseInt","onConnectHandler","connectedChainId","isHexStrict","reconnected","rehydrated","subscribeEvents","connector","getWalletConnectInstance","walletConnectOptions"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError, isHexStrict } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\"\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        this.connector = this.getWalletConnectInstance();\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$2;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId\", chainId);\n    const connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n    if (connectedChainId !== parseInt(this.chainConfig.chainId, 16)) {\n      // we need to create a new session since old session is already used and\n      // user needs to login again with correct chain with new qr code.\n      await this.createNewSession({\n        forceNewSession: true\n      });\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(connectedChainId, \", Please switch to correct chain from wallet\")));\n      return;\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}